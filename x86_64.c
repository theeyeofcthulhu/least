#include <assert.h>
#include <string.h>
#include <stdlib.h>

#include "util.h"
#include "error.h"
#include "x86_64.h"
#include "ast.h"

#define MAX_DIGITS 32

typedef struct{
    int op_enum;
    char* asm_name;
    char* opposite_asm_name;
}cmp_operation;

const cmp_operation cmp_operation_structs[CMP_OPERATION_ENUM_END] = {
{EQUAL,         "je",   "jne"},
{NOT_EQUAL,     "jne",  "je"},
{LESS,          "jl",   "jge"},
{LESS_OR_EQ,    "jle",  "jg"},
{GREATER,       "jg",   "jle"},
{GREATER_OR_EQ, "jge",  "jl"},
};

typedef struct{
    int op_enum;
    char* source_name;
    char* asm_name;
}logical_operation;

const logical_operation logical_operation_structs[LOGICAL_OPS_END] = {
{AND,   "&&",   "and"},
{OR,    "||",   "or"},
};

char* asm_from_var_or_const(tree_node* node);
void free_internal_strs();
void arithmetic_tree_to_x86_64(tree_node* root, char* reg, FILE* out, struct compile_info* c_info);
void ast_to_x86_64_core(tree_node* root, FILE* out, struct compile_info* c_info, int body_id, int real_end_id);

char* var_or_const = NULL;

/* Get an assembly reference to a variable or a constant
 * The returned char* is entered into an array and is free'd
 * at the end */
char* asm_from_var_or_const(tree_node* node){
    if(!var_or_const)
        var_or_const = malloc((strlen("qword [rbp - ]") + MAX_DIGITS) * sizeof(char));

    assert(node->cls == T_VAR || node->cls == T_CONST);

    if(node->cls == T_VAR){
        sprintf(var_or_const, "qword [rbp - %d]", (node->op.n_var + 1) * 8);
    }else if(node->cls == T_CONST){
        sprintf(var_or_const, "%d", node->op.value);
    }

    return var_or_const;
}

/* Collect strings allocated by asm_from_var_or_const
 * These are used swiftly and pointers to them are not saved,
 * so we collect them */
void free_internal_strs(){
    if(var_or_const)
        free(var_or_const);
}

void print_mov_if_req(char* target, char* source, FILE* out){
    if(strcmp(target, source) != 0)
        fprintf(out, "mov %s, %s\n", target, source);
}

/* Parse a tree representing an arithmetic expression into assembly recursively */
void arithmetic_tree_to_x86_64(tree_node* root, char* reg, FILE* out, struct compile_info* c_info){
    /* If we are only a number: mov us into the target and leave */
    if(root->cls == T_VAR || root->cls == T_CONST){
        fprintf(out, "mov %s, %s\n\n", reg, asm_from_var_or_const(root));
        return;
    }

    assert(root->op.arit.left->cls == T_ARIT ||
           root->op.arit.left->cls == T_CONST ||
           root->op.arit.left->cls == T_VAR);
    assert(root->op.arit.right->cls == T_ARIT ||
           root->op.arit.right->cls == T_CONST ||
           root->op.arit.right->cls == T_VAR);

    bool value_in_rax = false;

    /* If our children are also calculations: recurse */
    if(root->op.arit.left->cls == T_ARIT){
        arithmetic_tree_to_x86_64(root->op.arit.left, "rax", out, c_info);
        value_in_rax = true;
    }if(root->op.arit.right->cls == T_ARIT){
        /* Preserve rax */
        if(value_in_rax)
            fprintf(out, "push rax\n\n");
        arithmetic_tree_to_x86_64(root->op.arit.right, "rcx", out, c_info);
        if(value_in_rax)
            fprintf(out, "pop rax\n\n");
    }

    /* If our children are numbers: mov them into the target */
    if(root->op.arit.left->cls == T_CONST || root->op.arit.left->cls == T_VAR)
        fprintf(out, "mov rax, %s\n\n", asm_from_var_or_const(root->op.arit.left));
    if(root->op.arit.right->cls == T_CONST || root->op.arit.right->cls == T_VAR)
        fprintf(out, "mov rcx, %s\n\n", asm_from_var_or_const(root->op.arit.right));

    /* Execute the calculation */
    switch(root->op.arit.arit_op){
        case ADD:
            fprintf(out, "add rax, rcx\n");
            print_mov_if_req(reg, "rax", out);
            break;
        case SUB:
            fprintf(out, "sub rax, rcx\n");
            print_mov_if_req(reg, "rax", out);
            break;
        case DIV:
            fprintf(out, "xor rdx, rdx\n"
                         "div rcx\n");
            print_mov_if_req(reg, "rax", out);
            break;
        case MOD:
            fprintf(out, "xor rdx, rdx\n"
                         "div rcx\n");
            print_mov_if_req(reg, "rdx", out);
            break;
        case MUL:
            fprintf(out, "xor rdx, rdx\n"
                         "mul rcx\n");
            print_mov_if_req(reg, "rax", out);
            break;
        case ARIT_OPERATION_ENUM_END:
            //TODO: tree line numbers
            compiler_error(0, "Invalid arithmetic operation\n");
            break;
    }

    fprintf(out, "\n");
}

void ast_to_x86_64(tree_node* root, char* fn, struct compile_info* c_info){
    FILE* out = fopen(fn, "w");

    fprintf(out, ";; Generated by Least Complicated Compiler (lcc)\n\n"
                 "global _start\n"
                 "section .text\n"
                 "_start:\n");

    if(c_info->var_id > 0)
        fprintf(out, "mov rbp, rsp\n"
                    "sub rsp, %d\n", (c_info->var_id) * 8);

    fprintf(out, "\n");

    ast_to_x86_64_core(root, out, c_info, root->op.body.body_id, root->op.body.body_id);

    fprintf(out, "mov rax, 60\n"
                 "xor rdi, rdi\n"
                 "syscall\n\n"
                 "section .data\n\n");

    for (int i = 0; i < c_info->string_id; i++) {
        fprintf(out, "str%d: db \"%s\"\n"
        "str%dLen: equ $ - str%d\n\n", i, c_info->known_strings[i], i, i);
    }

    if(c_info->req_libs[LIB_UPRINT])
        fprintf(out, "extern uprint\n");
    if(c_info->req_libs[LIB_PUTCHAR])
        fprintf(out, "extern putchar\n");

    fclose(out);

    free_internal_strs();
}

void ast_to_x86_64_core(tree_node* root, FILE* out, struct compile_info* c_info, int body_id, int real_end_id){
    switch(root->cls){
        case T_BODY:
            for(int i = 0; i < root->op.body.n_children; i++){
                ast_to_x86_64_core(root->op.body.children[i], out, c_info, root->op.body.body_id, real_end_id);
            }
            break;
        case T_IF:
        {
            /* Getting the end label for the whole block
             * we jmp there if one if succeeded and we traversed its block */
            tree_node* last_if = get_last_if(root);
            if(last_if->cls == T_ELSE){
                real_end_id = last_if->op.t_else.body->op.body.body_id;
            }else{
                real_end_id = last_if->op.t_if.body->op.body.body_id;
            }

            fprintf(out, ";; if\n");
            ast_to_x86_64_core(root->op.t_if.condition, out, c_info, root->op.t_if.body->op.body.body_id, real_end_id);
            ast_to_x86_64_core(root->op.t_if.body, out, c_info, root->op.t_if.body->op.body.body_id, real_end_id);
            /* If we have an elif: jmp there after finishing the block */
            if(root->op.t_if.elif != NULL){
                fprintf(out, "jmp .end%d\n\n", real_end_id);
                fprintf(out, ".end%d:\n\n", root->op.t_if.body->op.body.body_id);
                ast_to_x86_64_core(root->op.t_if.elif, out, c_info, root->op.t_if.body->op.body.body_id, real_end_id);
            }else
                fprintf(out, ".end%d:\n\n", root->op.t_if.body->op.body.body_id);
            break;
        }
        case T_ELIF:
            fprintf(out, ";; elif\n");
            ast_to_x86_64_core(root->op.t_if.condition, out, c_info, root->op.t_if.body->op.body.body_id, real_end_id);
            ast_to_x86_64_core(root->op.t_if.body, out, c_info, root->op.t_if.body->op.body.body_id, real_end_id);
            if(root->op.t_if.elif != NULL){
                fprintf(out, "jmp .end%d\n\n", real_end_id);
                fprintf(out, ".end%d:\n\n", root->op.t_if.body->op.body.body_id);
                ast_to_x86_64_core(root->op.t_if.elif, out, c_info, root->op.t_if.body->op.body.body_id, real_end_id);
            }else
                fprintf(out, ".end%d:\n\n", root->op.t_if.body->op.body.body_id);
            break;
        case T_ELSE:
            fprintf(out, ";; else\n");
            ast_to_x86_64_core(root->op.t_else.body, out, c_info, root->op.t_else.body->op.body.body_id, real_end_id);
            fprintf(out, ".end%d:\n\n", root->op.t_else.body->op.body.body_id);
            break;
        case T_WHILE:
            fprintf(out, ";; while\n");
            fprintf(out, ".entry%d:\n\n", root->op.t_while.body->op.body.body_id);
            ast_to_x86_64_core(root->op.t_while.condition, out, c_info, root->op.t_while.body->op.body.body_id, real_end_id);
            ast_to_x86_64_core(root->op.t_while.body, out, c_info, root->op.t_while.body->op.body.body_id, real_end_id);
            fprintf(out, "jmp .entry%d\n\n", root->op.t_while.body->op.body.body_id);
            fprintf(out, ".end%d:\n\n", root->op.t_while.body->op.body.body_id);
            break;
        case T_FUNC:
        {
            //TODO: arit operations as function args
            switch(root->op.func_args.func){
                case EXIT:
                    compiler_error_on_true(root->op.func_args.n_args != 1,
                                           0, "Expected one argument to 'exit'\n");
                    compiler_error_on_false(root->op.func_args.args[0]->cls == T_VAR ||
                                            root->op.func_args.args[0]->cls == T_CONST,
                                            0, "Expected variable or constant\n");
                    fprintf(out, "mov rax, 60\n");
                    if(root->op.func_args.args[0]->cls == T_VAR){
                        compiler_error_on_false(check_defined(*c_info, root->op.func_args.args[0]->op.n_var),
                                                0,
                                                "Variable '%s' is undefined at this time\n",
                                                c_info->known_vars[root->op.func_args.args[0]->op.n_var]);
                        fprintf(out, "mov rdi, %s\n",
                                asm_from_var_or_const(root->op.func_args.args[0]));
                    }else if(root->op.func_args.args[0]->cls == T_CONST){
                        fprintf(out, "mov rdi, %d\n", root->op.func_args.args[0]->op.value);
                    }
                    fprintf(out, "syscall\n");
                    break;
                case INT:
                    compiler_error_on_true(root->op.func_args.n_args != 2,
                                           0, "Expected two arguments to 'int'\n");
                    compiler_error_on_false(root->op.func_args.args[0]->cls == T_VAR,
                                            0, "Expected variable\n");
                    compiler_error_on_false(root->op.func_args.args[1]->cls == T_VAR ||
                                            root->op.func_args.args[1]->cls == T_CONST,
                                            0, "Expected variable or constant\n");
                    compiler_error_on_true(check_defined(*c_info, root->op.func_args.args[0]->op.n_var),
                                           0,
                                           "Redefinition of '%s', use 'set' instead\n",
                                           c_info->known_vars[root->op.func_args.args[0]->op.n_var]);

                    fprintf(out, "mov qword [rbp - %d], %d\n",
                            (root->op.func_args.args[0]->op.n_var + 1) * 8,
                            root->op.func_args.args[1]->op.value);

                    c_info->defined_vars[root->op.func_args.args[0]->op.n_var] = true;
                    break;
                case PRINT:
                    compiler_error_on_true(root->op.func_args.n_args != 1,
                                           0, "Expected one argument to 'print'\n");
                    compiler_error_on_false(root->op.func_args.args[0]->cls == T_LSTR,
                                            0, "Expected string\n");
                    tree_node* ls = root->op.func_args.args[0];
                    for(int i = 0; i < ls->op.lstr.n_format; i++){
                        switch(ls->op.lstr.format[i]->cls){
                            case T_STR:
                                fprintf(out, "mov rax, 1\n"
                                            "mov rdi, 1\n"
                                            "mov rsi, str%d\n"
                                            "mov rdx, str%dLen\n"
                                            "syscall\n",
                                            ls->op.lstr.format[i]->op.n_str,
                                            ls->op.lstr.format[i]->op.n_str);
                                break;
                            case T_VAR:
                            case T_CONST:
                                fprintf(out, "mov rax, %s\n"
                                             "call uprint\n", asm_from_var_or_const(ls->op.lstr.format[i]));
                                c_info->req_libs[LIB_UPRINT] = true;
                                break;
                            default:
                                compiler_error(0, "Unexpected format token in string\n");
                        }
                    }
                    break;
                case SET:
                    compiler_error_on_true(root->op.func_args.n_args != 2,
                                           0, "Expected two arguments to 'set'\n");

                    compiler_error_on_false(root->op.func_args.args[0]->cls == T_VAR,
                                            0, "Expected variable\n");
                    compiler_error_on_false(check_defined(*c_info, root->op.func_args.args[0]->op.n_var), 0, "Variable undefined\n");

                    switch(root->op.func_args.args[1]->cls){
                        case T_ARIT:
                            fprintf(out, ";; set\n");
                            arithmetic_tree_to_x86_64(root->op.func_args.args[1],
                                                      "r8",
                                                      out, c_info);
                            fprintf(out, "mov %s, r8\n", asm_from_var_or_const(root->op.func_args.args[0]));
                            break;
                        case T_VAR:
                            compiler_error_on_false(check_defined(*c_info, root->op.func_args.args[1]->op.n_var), 0, "Variable undefined\n");
                            __attribute__ ((fallthrough)); /* Tell gcc (and you) that we are willing to fall through here */
                        case T_CONST:
                            fprintf(out, ";; set\n"
                                         "mov %s, %s\n", asm_from_var_or_const(root->op.func_args.args[0]),
                                                         asm_from_var_or_const(root->op.func_args.args[1]));
                            break;
                        default:
                            compiler_error(0, "Unexpected argument to set");
                    }
                    break;
                case PUTCHAR:
                case READ:
                    compiler_error(0, "TODO: unimplemented\n");
                    break;
            }
            fprintf(out, "\n");
            break;
        }
        case T_CMP:
        {
            arithmetic_tree_to_x86_64(root->op.sides.left, "r8", out, c_info);
            if(root->op.sides.right){
                arithmetic_tree_to_x86_64(root->op.sides.right, "r9", out, c_info);
                fprintf(out, "cmp r8, r9\n"
                             "%s .end%d\n\n",
                             cmp_operation_structs[root->op.sides.cmp].opposite_asm_name,
                             body_id);
            /* If we are not comparing something: just check against zero */
            }else{
                fprintf(out, "cmp r8, 0\n"
                             "%s .end%d\n\n",
                             cmp_operation_structs[NOT_EQUAL].opposite_asm_name,
                             body_id);
            }

            break;
        }
        default:
            compiler_error(0, "Unexpected tree node\n");
            break;
    }
}
