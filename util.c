#include <string.h>
#include <stdlib.h>
#include <stdbool.h>
#include <unistd.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <fcntl.h>

#include "util.h"
#include "error.h"

/* Unite an array of strings into a single string with the elements separated by spaces */
char* unite(char** src, int off, int len){
    char* out;
    int out_len = 0;

    for(int i = off; i < len + off; i++)
        out_len += strlen(src[i]);

    /* Account for spaces */
    out_len += len - 1;

    out = malloc((out_len + 1) * sizeof(char));
    memset(out, '\0', out_len + 1);

    for(int i = off; i < len + off - 1; i++){
        strcat(out, src[i]);
        strcat(out, " ");
    }
    strcat(out, src[len + off - 1]);

    return out;
}

/* Separate src by spaces (gobble up duplicate spaces) into array of strings.
 * Store length of array in dest_len. */
char** sepbyspc(char* src, int* dest_len){
    if(!src)
        return NULL;

    int src_len = strlen(src);

    if(src_len == 0)
        return NULL;

    char* src_cpy = malloc((src_len + 1) * sizeof(char));
    strcpy(src_cpy, src);

    char** dest;
    *dest_len = 0;

    for(int i = 0, repeat = 0; i < src_len; i++){
        if(src_cpy[i] == ' ' && !repeat){
            *dest_len += 1;
            repeat = 1;
        }else if(!(src_cpy[i] == ' ')){
            repeat = 0;
        }
    }
    *dest_len += 1;

    dest = malloc((*dest_len + 1) * sizeof(char*));

    char* src_word;
    char* src_copy_ptr = src_cpy;
    /* control_copy_ptr becomes NULL after first iteration since every call to strtok after the first one
     * which is supposed to operate on the same string has to be with NULL as str. */
    for(int i = 0; i < *dest_len; src_copy_ptr = NULL, i++){
        src_word = strtok(src_copy_ptr, " ");
        if(!src_word)
            break;
        int src_word_len = strlen(src_word);

        dest[i] = malloc((src_word_len + 1) * sizeof(char));
        strcpy(dest[i], src_word);
    }

    free(src_cpy);

    return dest;
}

/* Free array generated by, for example, sepbyspc where the array itself is also malloc'd */
void freewordarr(char** arr, int len){
    for(int i = 0; i < len; i++)
        free(arr[i]);

    free(arr);
}

char** spltlns(char* str, int *len){
    *len = 0;
    /* Count newlines */
    for(size_t i = 0; i < strlen(str); i++)
        if(str[i] == '\n')
            *len += 1;

    /* Split file by '\n' chars and load into lines
     *
     * We can't use pure strtok() because multiple '\n's would all be eliminated and
     * we want to count empty lines as well */
    char** lines = malloc(*len * sizeof(char*));
    char* offset = str;

    bool found_all = false;
    int accumulator = 0;
    while(!found_all){
        /* Exit if no more newlines are found */
        char* next_offset = index(offset, '\n');
        if(!next_offset){
            found_all = true;
            break;
        }
        /* If line is empty, set line to NULL and continue to next iteration */
        if(next_offset - offset <= 0){
            lines[accumulator++] = NULL;
            offset = next_offset + 1;
            continue;
        }

        /* Ignore spaces at beginning of line */
        char* space_offset = offset;
        for(; space_offset < next_offset; space_offset++){
            if(*space_offset != ' ')
                break;
        }

        lines[accumulator] = malloc(((int)(next_offset - space_offset) + 1) * sizeof(char));
        memcpy(lines[accumulator], space_offset, (int)(next_offset - space_offset));
        lines[accumulator][(int)(next_offset - space_offset)] = '\0';

        offset = next_offset + 1;
        accumulator++;
    }

    return lines;
}

struct compile_info* create_c_info(){
    struct compile_info* res = malloc(sizeof(struct compile_info));

    res->body_id = NODE_ARR_SZ;
    res->var_id = 0;
    res->string_id = 0;

    memset(res->defined_vars, 0, NODE_ARR_SZ * sizeof(bool));
    memset(res->known_vars, 0, NODE_ARR_SZ * sizeof(char*));
    memset(res->known_strings, 0, NODE_ARR_SZ * sizeof(char*));
    memset(res->req_libs, 0, LIB_ENUM_END * sizeof(bool));

    return res;
}

char* read_source_code(char* filename){
    int input_file = open(filename, O_RDONLY);
    compiler_error_on_true(input_file < 0, 0, "Could not open file '%s'\n", filename);

    struct stat file_stat = {0};
    compiler_error_on_true((fstat(input_file, &file_stat)) < 0, 0, "Could not stat file '%s'\n", filename);

    int input_size = file_stat.st_size;

    char* result = mmap(NULL, input_size, PROT_READ, MAP_PRIVATE, input_file, 0);
    compiler_error_on_false(result, 0, "Failed to map file '%s'\n", filename);

    close(input_file);

    return result;
}
